# 矩阵乘法
## 两个矩阵相乘
### 概述
```
Tensor C(Shape = {M, N}, Stride = {N, 1});
Tensor A(Shape = {M, K}, Stride = {K, 1});
Tensor B(Shape = {K, N}, Stride = {N, 1});
```
计算 $C=A*B$ ,矩阵 $C, A, B$ 由 $Shape, Stride$ 描述

逻辑形式由 $Shape$ 描述：

$$
C = 
\begin{bmatrix}
c_{11} & c_{12} & {\cdots} & c_{1N} \\
c_{21} & c_{22} & {\cdots} & c_{2N} \\
{\vdots}&{\vdots}&{\ddots}&{\vdots} \\
c_{M1} & c_{M2} & {\cdots} & c_{MN}
\end{bmatrix}, 
A = \begin{bmatrix}
a_{11} & a_{12} & {\cdots} & a_{1K} \\
a_{21} & a_{22} & {\cdots} & a_{2K} \\
{\vdots}&{\vdots}&{\ddots}&{\vdots} \\
a_{M1} & a_{M2} & {\cdots} & a_{MK}
\end{bmatrix},
B=\begin{bmatrix}
b_{11} & b_{12} & {\cdots} & b_{1N} \\
b_{21} & b_{22} & {\cdots} & b_{2N} \\
{\vdots}&{\vdots}&{\ddots}&{\vdots} \\
b_{K1} & b_{K2} & {\cdots} & b_{KN}
\end{bmatrix},
$$

存储形式由 $Stride$ 描述

计算量: $2 * M * N * K$

访存量主要计算显存(Global Memory)的读写量，忽略缓存读写量, $i,j$ 分别表示 $i$ 行和 $j$ 列

### 四种循环
#### M->N->K
```
Tensor C(Shape = {M, N}, Stride = {N, 1});
Tensor A(Shape = {M, K}, Stride = {1, K});
Tensor B(Shape = {K, N}, Stride = {N, 1});

for (int m = 0; m < M; m++) {
    for (int n = 0; n < N; n++) {
        for (int k = 0; k < K; k++) {
            C(i, j) = C[i * C.Stride[0] + j * C.Stride[1]];
            A(i, k) = A[i * A.Stride[0] + k * A.Stride[1]];
            B(k, j) = B[k * B.Stride[0] + j * B.Stride[1]];
            C(i, j) = C(i, j) + A(i, k) * B(k, j);
        }
    }
}
```
存储形式由 $Stride$ 描述

$C$ 行优先：
$[c_{11},c_{12},...,c_{1N},c_{21},c_{22},...,c_{2N},...,c_{M1},c_{M2},...,c_{MN}]$

$A$ 行优先：
$[a_{11},a_{12},...,a_{1K},a_{21},a_{22},...,a_{2K},...,a_{M1},a_{M2},...,a_{MK}]$

$B$ 列优先：
$[b_{11},b_{21},...,b_{K1},b_{12},b_{22},...,b_{K2},...,b_{1M},b_{2M},...,b_{KM}]$

#### 无缓存：
        $$C_w=MN$$
        $$A_r=MKN$$
        $$B_r=KNM$$
        $$total=2MNK+M*N$$
        $$CI = \frac{2MNK}{2MNK+MN} = \frac{2}{2+1/K}=O(1)$$

2.可以缓存下 $A(i)$ 
        $$C_w=MN$$
        $$A_r=MK$$
        $$B_r=KNM$$
        $$total=MNK+MN+MK$$
        $$CI = \frac{2MNK}{MNK+MN+MK} = \frac{2}{1+1/K+1/N}=O(2)$$

3.可以缓存下 $A(i)$ 和整个 $B$ 
        $$C_w=MN$$
        $$A_r=MK$$
        $$B_r=KN$$
        $$total=MN+MK+KN$$
        $$CI = \frac{2MNK}{MN+MK+KN} = \frac{2}{1/K+1/N+1/M}=O(inf)$$
```
for (int n = 0; n < N; n++) {
    for (int m = 0; m < M; m++) {
        for (int k = 0; k < K; k++) {
            C(i, j) = C[i * C.Stride[0] + j * C.Stride[1]];
            A(i, k) = A[i * A.Stride[0] + k * A.Stride[1]];
            B(k, j) = B[k * B.Stride[0] + j * B.Stride[1]];
            C(i, j) = C(i, j) + A(i, k) * B(k, j);
        }
    }
}
```
1.无缓存：
        $$C_w=MN$$
        $$A_r=MKN$$
        $$B_r=KNM$$
        $$total=2MNK+MN$$
        $$CI = \frac{2MNK}{2MNK+MN} = \frac{2}{2+1/K}=O(1)$$
2.可以缓存下 $B(j)$ 
        $$C_w=MN$$
        $$A_r=MKN$$
        $$B_r=KN$$
        $$total=MNK+MN+KN$$
        $$CI = \frac{2MNK}{MNK+MN+KN} = \frac{2}{1+1/K+1/M}=O(2)$$

3.可以缓存下整个 $A$ 和 $B(j)$ 
        $$C_w=MN$$
        $$A_r=MK$$
        $$B_r=KN$$
        $$total=MN+MK+KN$$
        $$CI=\frac{2MNK}{MN+MK+KN} = \frac{2}{1/K+1/N+1/M}=O(inf)$$
```
for (int k = 0; k < K; k++){
    for (int m = 0; m < M; m++) {
        for (int n = 0; n < N; n++) {
            C(i, j) = C[i * C.Stride[0] + j * C.Stride[1]];
            A(i, k) = A[i * A.Stride[0] + k * A.Stride[1]];
            B(k, j) = B[k * B.Stride[0] + j * B.Stride[1]];
            C(i, j) = C(i, j) + A(i, k) * B(k, j);
        }
    }
}
```
1.无缓存：
        $$C_w=MNK$$
        $$A_r=MK$$
        $$B_r=KNM$$
        $$total=2MNK+MK$$
        $$CI = \frac{2MNK}{2MNK+MK} = \frac{2}{2+1/N}=O(1)$$
2.可以缓存下 $B(j)$ 
        $$C_w=MNK$$
        $$A_r=MK$$
        $$B_r=KN$$
        $$total=MNK+MK+KN$$
        $$CI = \frac{2MNK}{MNK+MK+KN} = \frac{2}{1+1/N+1/M}=O(2)$$

3.可以缓存下整个 $C$ 和 $B(j)$ 
        $$C_w=MN$$
        $$A_r=MK$$
        $$B_r=KN$$
        $$total=MN+MK+KN$$
        $$CI = \frac{2MNK}{MN+MK+KN} = \frac{2}{1/K+1/N+1/M}=O(inf)$$

```
for (int k = 0; k < K; k++){
    for (int n = 0; n < N; n++) {
         for (int m = 0; m < M; m++){
            C(i, j) = C[i * C.Stride[0] + j * C.Stride[1]];
            A(i, k) = A[i * A.Stride[0] + k * A.Stride[1]];
            B(k, j) = B[k * B.Stride[0] + j * B.Stride[1]];
            C(i, j) = C(i, j) + A(i, k) * B(k, j);
        }
    }
}
```

1.无缓存：
        $$C_w=MNK$$
        $$A_r=MKN$$
        $$B_r=KN$$
        $$total=2MNK+KN$$
        $$CI = \frac{2MNK}{2MNK+KN} = \frac{2}{2+1/M}=O(1)$$
2.可以缓存下 $A(j)$ 
        $$C_w=MNK$$ 
        $$A_r=MK$$
        $$B_r=KN$$
        $$total=MNK+MK+KN$$
        $$CI = \frac{2MNK}{MNK+MK+KN} = \frac{2}{1+1/N+1/M}=O(2)$$

3.可以缓存下整个 $C$ 和 $A(j)$
        $$C_w=MN$$
        $$A_r=MK$$
        $$B_r=KN$$
        $$total=MN+MK+KN$$
        $$CI = \frac{2MNK}{MN+MK+KN} = \frac{2}{1/K+1/N+1/M}=O(inf)$$
